# Stored XSS into HTML context with nothing encoded

## Theory

<h3>Что такое хранимый XSS?</h3>

Хранимый XSS (также известный как вторичный или постоянный XSS) возникает, когда приложение получает данные из ненадежного источника и включает эти данные в свои более поздние HTTP-ответы небезопасным способом.

Предположим, веб-сайт позволяет пользователям оставлять комментарии к сообщениям в блогах, которые отображаются для других пользователей. Пользователи отправляют комментарии с помощью HTTP-запроса, например:
```
POST /post/comment HTTP/1.1
Host: vulnerable-website.com
Content-Length: 100

postId=3&comment=This+post+was+extremely+helpful.&name=Carlos+Montoya&email=carlos%40normal-user.net
```

После отправки этого комментария любой пользователь, посетивший сообщение в блоге, получит в ответе приложения следующее:
```
<p>This post was extremely helpful.</p>
```

Предполагая, что приложение не выполняет никакой другой обработки данных, злоумышленник может отправить вредоносный комментарий, подобный этому:
```
<script>/* Bad stuff here... */</script>
```

В запросе злоумышленника этот комментарий будет закодирован в URL как:
```
comment=%3Cscript%3E%2F*%2BBad%2Bstuff%2Bhere...
```

Любой пользователь, посетивший сообщение в блоге, теперь получит в ответе приложения следующее:
```
<p><script>/* Bad stuff here... */</script></p>
```

Сценарий, предоставленный злоумышленником, затем будет выполняться в браузере пользователя-жертвы в контексте его сеанса с приложением.

<h3>Как найти и протестировать хранимые XSS-уязвимости</h3>

Тестирование сохраненных XSS-уязвимостей вручную может быть сложной задачей. Вам необходимо протестировать все соответствующие «точки входа», через которые данные, контролируемые злоумышленником, могут попасть в обработку приложения, и все «точки выхода», в которых эти данные могут появиться в ответах приложения.

Точки входа в обработку заявки включают:

* Параметры или другие данные в строке запроса URL и тексте сообщения.
* Путь к файлу URL.
* Заголовки HTTP-запросов, которые могут быть неприменимы в отношении отраженного XSS.
* Любые внеполосные маршруты, по которым злоумышленник может доставить данные в приложение. Существующие маршруты полностью зависят от функциональности, реализуемой приложением: приложение веб-почты будет обрабатывать данные, полученные в электронных письмах; приложение, отображающее ленту Twitter, может обрабатывать данные, содержащиеся в сторонних твитах; а агрегатор новостей будет включать данные с других веб-сайтов.

Точки выхода для сохраненных XSS-атак — это все возможные ответы HTTP, которые возвращаются любому пользователю приложения в любой ситуации.

Первым шагом в тестировании сохраненных уязвимостей XSS является обнаружение связей между точками входа и выхода, посредством чего данные, отправленные в точку входа, отправляются из точки выхода. Причины, по которым это может быть сложно, заключаются в следующем:

* Данные, передаваемые в любую точку входа, в принципе могут быть отправлены из любой точки выхода. Например, введенные пользователем отображаемые имена могут отображаться в малоизвестном журнале аудита, который виден только некоторым пользователям приложения.
* Данные, которые в настоящее время хранятся в приложении, часто могут быть перезаписаны из-за других действий, выполняемых в приложении. Например, функция поиска может отображать список последних поисковых запросов, которые быстро заменяются, когда пользователи выполняют другие поисковые запросы.

Чтобы всесторонне идентифицировать связи между точками входа и выхода, потребуется протестировать каждую перестановку отдельно, передать определенное значение в точку входа, перейти непосредственно к точке выхода и определить, появляется ли значение там. Однако этот подход нецелесообразен в приложении, содержащем более нескольких страниц.

Вместо этого более реалистичным подходом является систематическая работа с точками ввода данных, отправка определенного значения в каждую из них и отслеживание ответов приложения для обнаружения случаев, когда представленное значение появляется. Особое внимание можно уделить соответствующим функциям приложения, таким как комментарии к сообщениям в блогах. Когда отправленное значение наблюдается в ответе, вам необходимо определить, действительно ли данные хранятся в разных запросах, а не просто отражаются в немедленном ответе.


## Writeup

Главная страница:

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(XSS)_Cross-site_scripting/Stored_XSS_into_HTML_context_with_nothing_encoded/assets/1.png)

Перейдем к посту и спустимся в низ страницы. Мы можем заметить поле для комментария.

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(XSS)_Cross-site_scripting/Stored_XSS_into_HTML_context_with_nothing_encoded/assets/2.png)

Запишем в поле комментария наш эксплоит и оставим комментарий. Код эксплоита:
```
<script>alert(1)</script>
```

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(XSS)_Cross-site_scripting/Stored_XSS_into_HTML_context_with_nothing_encoded/assets/3.png)

Теперь при переходе на страницу, приложение каждый раз будет будет вызывать alert(1).

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(XSS)_Cross-site_scripting/Stored_XSS_into_HTML_context_with_nothing_encoded/assets/4.png)

Получаем ответ от сервера.

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(XSS)_Cross-site_scripting/Stored_XSS_into_HTML_context_with_nothing_encoded/assets/5.png)
