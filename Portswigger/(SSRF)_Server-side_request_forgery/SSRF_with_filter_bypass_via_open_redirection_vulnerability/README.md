# SSRF with filter bypass via open redirection vulnerability

## Theory

<h3>Обход фильтров SSRF через открытое перенаправление</h3>

Иногда можно обойти любую защиту на основе фильтров, используя открытую уязвимость перенаправления.

Предположим, что введенный пользователем URL-адрес строго проверяется, чтобы предотвратить злонамеренное использование поведения SSRF. Однако приложение, URL-адреса которого разрешены, содержит открытую уязвимость перенаправления. При условии, что API, используемый для создания серверного HTTP-запроса, поддерживает перенаправления, вы можете создать URL-адрес, который удовлетворяет фильтру и приводит к перенаправлению запроса на желаемую внутреннюю цель.

Например, предположим, что приложение содержит открытую уязвимость перенаправления, в которой следующий URL-адрес:
```
/product/nextProduct?currentProductId=6&path=http://evil-user.net
```
возвращает перенаправление на:
```
http://evil-user.net
```

Вы можете использовать уязвимость открытого перенаправления, чтобы обойти фильтр URL-адресов, и использовать уязвимость SSRF следующим образом:
```
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://weliketoshop.net/product/nextProduct?currentProductId=6&path=http://192.168.0.68/admin
```

Этот эксплойт SSRF работает, потому что приложение сначала проверяет, что предоставленный URL-адрес stockAPI находится в разрешенном домене, что так и есть. Затем приложение запрашивает предоставленный URL-адрес, который запускает открытое перенаправление. Он следует за перенаправлением и делает запрос на внутренний URL-адрес по выбору злоумышленника.

## Writeup

Главная страница:

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(SSRF)_Server-side_request_forgery/SSRF_with_filter_bypass_via_open_redirection_vulnerability/assets/1.png)

Выберем любой продукт.

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(SSRF)_Server-side_request_forgery/SSRF_with_filter_bypass_via_open_redirection_vulnerability/assets/2.png)

Перейдем на его страницу и спустимся в самый низ.

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(SSRF)_Server-side_request_forgery/SSRF_with_filter_bypass_via_open_redirection_vulnerability/assets/3.png)

Нажмем на кнопку "Check stock" и перехватим запрос. Отправим его в Repeater.

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(SSRF)_Server-side_request_forgery/SSRF_with_filter_bypass_via_open_redirection_vulnerability/assets/4.png)

На странице продукта найдем кнопку "Next product". Нажмем на нее и перехватим запрос. Отправляем его в Repeater.

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(SSRF)_Server-side_request_forgery/SSRF_with_filter_bypass_via_open_redirection_vulnerability/assets/5.png)

Возьмем наш GET запрос и скопируем его. Вставим его в stockApi и изменим значение path на нужное нам.
```
/product/nextProduct?currentProductId=1&path=http://192.168.0.12:8080/admin
```

Закодируем нашу строку. Отправляем запрос.

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(SSRF)_Server-side_request_forgery/SSRF_with_filter_bypass_via_open_redirection_vulnerability/assets/6.png)

Скопируем функцию удаления пользователя и вставим в stockApi. Отправляем запрос.

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(SSRF)_Server-side_request_forgery/SSRF_with_filter_bypass_via_open_redirection_vulnerability/assets/7.png)

Получаем ответ от сервера.

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(SSRF)_Server-side_request_forgery/SSRF_with_filter_bypass_via_open_redirection_vulnerability/assets/8.png)
